
struct VoxelGrid {
    Transform transform;

    float32* data;
    uint32 res;

    Mesh mesh;
    uint32 numVerts;
    vec2* verts;
    uint32* inds; // list
}

const TopLeftBit = 8;
const TopRightBit = 4;
const BottomLeftBit = 2;
const BottomRightBit = 1;

const PointOnThreshold = 0.001;

void addTri(void** list, uint32 i1, uint32 i2, uint32 i3) {
    add(list, *i1);
    add(list, *i2);
    add(list, *i3);
}

uint32 getIndex(uint32 res, uint32 x, uint32 y) {
    return x * res + y;
}

VoxelGrid createVoxelGrid(uint32 res) {
    VoxelGrid grid;
    grid.transform.pos = vec(0, 0);
    grid.transform.rot = 0;
    // grid.transform.scale = 1;

    grid.res = res;
    grid.data = alloc float32[res * res];

    //              3r^2 - 2r
    grid.numVerts = 3 * grid.res * grid.res - 2 * grid.res;
    grid.verts = alloc vec2[grid.numVerts];

    float32 half = grid.res as float32 / 2.0;

    for uint32 x in 0 .. grid.res {
        for uint32 y in 0 .. grid.res {
            let i = getIndex(grid.res, x, y);
            grid.verts[i].x = x as float32 - half;
            grid.verts[i].y = y as float32 - half;
        }
    }

    grid.inds = createList(sizeof uint32);
    grid.mesh = createMesh();

    return grid;
}

void updateGridMesh(VoxelGrid* grid) {

    listClear(grid.inds);

    uint32 size = grid.res - 1;
    let g1_size = grid.res * grid.res;
    let g2_size = grid.res * size;

    for uint32 x in 0 .. size {
        for uint32 y in 0 .. size {

            /*
                *--------1--------*
                |                 |
                |                 |
                |                 |
                2                 3
                |                 |
                |                 |
                |                 |
                *--------4--------*
            */

            let e2 = g1_size + x * size + y;
            let e3 = g1_size + (x + 1) * size + y;
            let e1 = g1_size + g2_size + x * grid.res + (y + 1);
            let e4 = g1_size + g2_size + x * grid.res + y;

            let i1 = getIndex(grid.res, x, y + 1);
            let i2 = getIndex(grid.res, x + 1, y + 1);
            let i3 = getIndex(grid.res, x, y);
            let i4 = getIndex(grid.res, x + 1, y);

            let p1 = grid.data[i1];
            let p2 = grid.data[i2];
            let p3 = grid.data[i3];
            let p4 = grid.data[i4];

            uint8 mask = 0;
            if p1 > PointOnThreshold mask |= TopLeftBit;
            if p2 > PointOnThreshold mask |= TopRightBit;
            if p3 > PointOnThreshold mask |= BottomLeftBit;
            if p4 > PointOnThreshold mask |= BottomRightBit;

            switch (mask) {

                // corners
                case TopLeftBit: addTri(*grid.inds, i1, e2, e1); break;
                case TopRightBit: addTri(*grid.inds, i2, e1, e3); break;
                case BottomRightBit: addTri(*grid.inds, i4, e3, e4); break;
                case BottomLeftBit: addTri(*grid.inds, i3, e4, e2); break;

                // inverted corners
                case 0x0F & ~TopLeftBit:
                    addTri(*grid.inds, i4, e1, e2);
                    addTri(*grid.inds, i4, i2, e1);
                    addTri(*grid.inds, i4, e2, i3);
                    break;
                case 0x0F & ~TopRightBit:
                    addTri(*grid.inds, i3, e3, e1);
                    addTri(*grid.inds, i3, i4, e3);
                    addTri(*grid.inds, i3, e1, i1);
                    break;
                case 0x0F & ~BottomRightBit:
                    addTri(*grid.inds, i1, e3, e4);
                    addTri(*grid.inds, i1, e3, i2);
                    addTri(*grid.inds, i1, e4, i3);
                    break;
                case 0x0F & ~BottomLeftBit:
                    addTri(*grid.inds, i2, e2, e4);
                    addTri(*grid.inds, i2, i1, e2);
                    addTri(*grid.inds, i2, e4, i4);
                    break;

                // horizontal 'walls'
                case TopLeftBit | TopRightBit:
                    addTri(*grid.inds, i1, e2, i2);
                    addTri(*grid.inds, i2, e2, e3);
                    break;
                case BottomLeftBit | BottomRightBit:
                    addTri(*grid.inds, i3, e3, e2);
                    addTri(*grid.inds, i4, e3, i3);
                    break;
                // vertical 'walls'
                case TopLeftBit | BottomLeftBit:
                    addTri(*grid.inds, i1, i3, e1);
                    addTri(*grid.inds, i3, e4, e1);
                    break;
                case TopRightBit | BottomRightBit:
                    addTri(*grid.inds, i2, e1, i4);
                    addTri(*grid.inds, i4, e1, e4);
                    break;

                // diagonals
                case TopLeftBit | BottomRightBit:
                    addTri(*grid.inds, i1, e2, e1);
                    addTri(*grid.inds, i4, e3, e4);
                    break;
                case TopRightBit | BottomLeftBit:
                    addTri(*grid.inds, i2, e1, e3);
                    addTri(*grid.inds, i3, e4, e2);
                    break;

                // solid block
                case 0x0F:
                    addTri(*grid.inds, i1, i3, i2);
                    addTri(*grid.inds, i2, i3, i4);
                    break;
            }
        }
    }

    if true { // smoothing

        float32 half = grid.res as float32 / 2.0;

        for uint32 x in 0 .. grid.res {
            for uint32 y in 0 .. size {

                let p1 = grid.data[getIndex(grid.res, x, y)];
                let p2 = grid.data[getIndex(grid.res, x, y + 1)];

                let b1 = p1 > PointOnThreshold;
                let b2 = p2 > PointOnThreshold;

                float32 ofs;
                if b1 == b2 ofs = 0.5;
                else if b1  ofs = p1;
                else        ofs = 1.0 - p2;

                let i = g1_size + x * size + y;
                grid.verts[i].x = x as float32 - half;
                grid.verts[i].y = y as float32 + ofs - half;
            }
        }

        for uint32 x in 0 .. size {
            for uint32 y in 0 .. grid.res {

                let p1 = grid.data[getIndex(grid.res, x, y)];
                let p2 = grid.data[getIndex(grid.res, x + 1, y)];

                let b1 = p1 > PointOnThreshold;
                let b2 = p2 > PointOnThreshold;

                float32 ofs;
                if b1 == b2 ofs = 0.5;
                else if b1  ofs = p1;
                else        ofs = 1.0 - p2;

                let i = g1_size + g2_size + x * grid.res + y;
                grid.verts[i].x = x as float32 + ofs - half;
                grid.verts[i].y = y as float32 - half;
            }
        }
    }

    updateMeshData(*grid.mesh, grid.verts, grid.numVerts, grid.inds, length(grid.inds));
}

vec2 getLocalCoords(VoxelGrid* grid, float32 x, float32 y) {
    let p = world2local(grid.transform, x, y);
    float32 half = grid.res as float32 / 2.0;
    p.x += half;
    p.y += half;
    return p;
}

void VoxelGrid_addCircle(VoxelGrid* grid, float32 radius, float32 x, float32 y) {

    let p = getLocalCoords(grid, x, y);
    int32 rx = round2int(p.x);
    int32 ry = round2int(p.y);

    int32 iradius = (radius + 1) as int32;
    int32 x_min = clamp(rx - iradius, 0, grid.res as int32);
    int32 x_max = clamp(rx + iradius, 0, grid.res as int32);
    int32 y_min = clamp(ry - iradius, 0, grid.res as int32);
    int32 y_max = clamp(ry + iradius, 0, grid.res as int32);

    for ix in x_min .. x_max {
        for iy in y_min .. y_max {
            float32 xf = ix as float32 - p.x;
            float32 yf = iy as float32 - p.y;
            float32 len = sqrtf(xf*xf + yf*yf);

            int32 i = ix * grid.res + iy;
            float32 addition = clamp(radius - len, 0, 1);
            if grid.data[i] < addition grid.data[i] = addition;
        }
    }
}

void VoxelGrid_removeCircle(VoxelGrid* grid, float32 radius, float32 x, float32 y) {

    let p = getLocalCoords(grid, x, y);
    int32 rx = round2int(p.x);
    int32 ry = round2int(p.y);

    int32 iradius = (radius + 1) as int32;
    int32 x_min = clamp(rx - iradius, 0, grid.res as int32);
    int32 x_max = clamp(rx + iradius, 0, grid.res as int32);
    int32 y_min = clamp(ry - iradius, 0, grid.res as int32);
    int32 y_max = clamp(ry + iradius, 0, grid.res as int32);

    for ix in x_min .. x_max {
        for iy in y_min .. y_max {
            float32 xf = ix as float32 - p.x;
            float32 yf = iy as float32 - p.y;
            float32 len = sqrtf(xf*xf + yf*yf);

            int32 i = ix * grid.res + iy;
            float32 newValue = clamp(len - radius, 0, 1);
            if grid.data[i] > newValue grid.data[i] = newValue;
        }
    }
}

int32 point_intersects(vec2 point, VoxelGrid* grid) {
    uint32 x = point.x as uint32;
    uint32 y = point.y as uint32;

    let i1 = getIndex(grid.res, x, y + 1);
    let i2 = getIndex(grid.res, x + 1, y + 1);
    let i3 = getIndex(grid.res, x, y);
    let i4 = getIndex(grid.res, x + 1, y);

    let p1 = grid.data[i1];
    let p2 = grid.data[i2];
    let p3 = grid.data[i3];
    let p4 = grid.data[i4];

    uint8 mask = 0;
    if p1 > PointOnThreshold mask |= TopLeftBit;
    if p2 > PointOnThreshold mask |= TopRightBit;
    if p3 > PointOnThreshold mask |= BottomLeftBit;
    if p4 > PointOnThreshold mask |= BottomRightBit;

    switch (mask) {
        case 0x0F: return true;
    }

    return false;
}

vec2 calcCenterOfMass(VoxelGrid* grid) {
    vec2 res = vec(0, 0);
    float32 total = 0;

    uint32 x = -1; while ++x < grid.res {
        uint32 y = -1; while ++y < grid.res {
            let i = x * grid.res + y;
            float32 value = grid.data[i];
            if value > PointOnThreshold {
                total += value;
                res = add(res, mul(vec(x, y), value));
            }
        }
    }

    res = mul(res, 1.0 / total);
    return res;
}