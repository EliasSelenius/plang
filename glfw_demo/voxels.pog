
struct VoxelGrid {
    float32* data;
    uint32 res;
}

struct VoxelMesh {
    Mesh mesh;
    uint32 numVerts;
    vec2* verts;
    uint32* inds; // list
}

const TopLeftBit = 8;
const TopRightBit = 4;
const BottomLeftBit = 2;
const BottomRightBit = 1;

const PointOnThreshold = 0.001;

vec2* initVertexBuffer(VoxelGrid grid, uint32* numVerts) {
    //             3r^2 - 2r
    @numVerts = 3 * grid.res * grid.res - 2 * grid.res;
    vec2* verts = alloc vec2[@numVerts]; // malloc(numVerts * sizeof vec2);

    uint32 x = -1;
    while ++x < grid.res {
        uint32 y = -1;
        while ++y < grid.res {
            let i = getIndex(grid.res, x, y);
            verts[i].x = x as float32;
            verts[i].y = y as float32;
        }
    }

    uint32 size = grid.res - 1;
    let g1_size = grid.res * grid.res;
    let g2_size = grid.res * size;


    x = -1;
    while ++x < grid.res {
        uint32 y = -1;
        while ++y < size {
            let i = g1_size + x * size + y;
            verts[i].x = x as float32;
            verts[i].y = 0.5 + y as float32;
        }
    }

    x = -1;
    while ++x < size {
        uint32 y = -1;
        while ++y < grid.res {
            let i = g1_size + g2_size + x * grid.res + y;
            verts[i].x = 0.5 + x as float32;
            verts[i].y = y as float32;
        }
    }

    return verts;
}

void addTri(void** list, uint32 i1, uint32 i2, uint32 i3) {
    add(list, *i1);
    add(list, *i2);
    add(list, *i3);
}

uint32 getIndex(uint32 res, uint32 x, uint32 y) {
    return x * res + y;
}

VoxelMesh generateMesh(VoxelGrid grid) {
    VoxelMesh vmesh;
    vmesh.verts = initVertexBuffer(grid, *vmesh.numVerts);
    vmesh.inds = createList(sizeof uint32);
    vmesh.mesh = createMesh();
    updateGridMesh(grid, *vmesh);
    return vmesh;
}

void updateGridMesh(VoxelGrid grid, VoxelMesh* vmesh) {

    listClear(vmesh.inds);

    uint32 size = grid.res - 1;
    let g1_size = grid.res * grid.res;
    let g2_size = grid.res * size;

    uint32 x = -1; while ++x < size {
        uint32 y = -1; while ++y < size {

            /*
                *--------1--------*
                |                 |
                |                 |
                |                 |
                2                 3
                |                 |
                |                 |
                |                 |
                *--------4--------*
            */

            let e2 = g1_size + x * size + y;
            let e3 = g1_size + (x + 1) * size + y;
            let e1 = g1_size + g2_size + x * grid.res + (y + 1);
            let e4 = g1_size + g2_size + x * grid.res + y;

            let i1 = getIndex(grid.res, x, y + 1);
            let i2 = getIndex(grid.res, x + 1, y + 1);
            let i3 = getIndex(grid.res, x, y);
            let i4 = getIndex(grid.res, x + 1, y);

            let p1 = grid.data[i1];
            let p2 = grid.data[i2];
            let p3 = grid.data[i3];
            let p4 = grid.data[i4];

            uint8 mask = 0;
            if p1 > PointOnThreshold mask |= TopLeftBit;
            if p2 > PointOnThreshold mask |= TopRightBit;
            if p3 > PointOnThreshold mask |= BottomLeftBit;
            if p4 > PointOnThreshold mask |= BottomRightBit;

            switch (mask) {

                // corners
                case TopLeftBit: addTri(*vmesh.inds, i1, e2, e1); break;
                case TopRightBit: addTri(*vmesh.inds, i2, e1, e3); break;
                case BottomRightBit: addTri(*vmesh.inds, i4, e3, e4); break;
                case BottomLeftBit: addTri(*vmesh.inds, i3, e4, e2); break;

                // inverted corners
                case 0x0F & ~TopLeftBit:
                    addTri(*vmesh.inds, i4, e1, e2);
                    addTri(*vmesh.inds, i4, i2, e1);
                    addTri(*vmesh.inds, i4, e2, i3);
                    break;
                case 0x0F & ~TopRightBit:
                    addTri(*vmesh.inds, i3, e3, e1);
                    addTri(*vmesh.inds, i3, i4, e3);
                    addTri(*vmesh.inds, i3, e1, i1);
                    break;
                case 0x0F & ~BottomRightBit:
                    addTri(*vmesh.inds, i1, e3, e4);
                    addTri(*vmesh.inds, i1, e3, i2);
                    addTri(*vmesh.inds, i1, e4, i3);
                    break;
                case 0x0F & ~BottomLeftBit:
                    addTri(*vmesh.inds, i2, e2, e4);
                    addTri(*vmesh.inds, i2, i1, e2);
                    addTri(*vmesh.inds, i2, e4, i4);
                    break;

                // horizontal 'walls'
                case TopLeftBit | TopRightBit:
                    addTri(*vmesh.inds, i1, e2, i2);
                    addTri(*vmesh.inds, i2, e2, e3);
                    break;
                case BottomLeftBit | BottomRightBit:
                    addTri(*vmesh.inds, i3, e3, e2);
                    addTri(*vmesh.inds, i4, e3, i3);
                    break;
                // vertical 'walls'
                case TopLeftBit | BottomLeftBit:
                    addTri(*vmesh.inds, i1, i3, e1);
                    addTri(*vmesh.inds, i3, e4, e1);
                    break;
                case TopRightBit | BottomRightBit:
                    addTri(*vmesh.inds, i2, e1, i4);
                    addTri(*vmesh.inds, i4, e1, e4);
                    break;

                // diagonals
                case TopLeftBit | BottomRightBit:
                    addTri(*vmesh.inds, i1, e2, e1);
                    addTri(*vmesh.inds, i4, e3, e4);
                    break;
                case TopRightBit | BottomLeftBit:
                    addTri(*vmesh.inds, i2, e1, e3);
                    addTri(*vmesh.inds, i3, e4, e2);
                    break;

                // solid block
                case 0x0F:
                    addTri(*vmesh.inds, i1, i3, i2);
                    addTri(*vmesh.inds, i2, i3, i4);
                    break;
            }
        }
    }

    if true { // smoothing
        x = -1; while ++x < grid.res {
            uint32 y = -1; while ++y < size {

                let p1 = grid.data[getIndex(grid.res, x, y)];
                let p2 = grid.data[getIndex(grid.res, x, y + 1)];

                let b1 = p1 > PointOnThreshold;
                let b2 = p2 > PointOnThreshold;

                float32 ofs;
                if b1 == b2 ofs = 0.5;
                else if b1  ofs = p1;
                else        ofs = 1.0 - p2;

                let i = g1_size + x * size + y;
                vmesh.verts[i].x = x as float32;
                vmesh.verts[i].y = y as float32 + ofs;
            }
        }

        x = -1; while ++x < size {
            uint32 y = -1; while ++y < grid.res {

                let p1 = grid.data[getIndex(grid.res, x, y)];
                let p2 = grid.data[getIndex(grid.res, x + 1, y)];

                let b1 = p1 > PointOnThreshold;
                let b2 = p2 > PointOnThreshold;

                float32 ofs;
                if b1 == b2 ofs = 0.5;
                else if b1  ofs = p1;
                else        ofs = 1.0 - p2;

                let i = g1_size + g2_size + x * grid.res + y;
                vmesh.verts[i].x = x as float32 + ofs;
                vmesh.verts[i].y = y as float32;
            }
        }
    }

    updateMeshData(*vmesh.mesh, vmesh.verts, vmesh.numVerts, vmesh.inds, length(vmesh.inds));
}

void VoxelGrid_addCircle(VoxelGrid grid, float32 radius, float32 x, float32 y) {

    int32 iradius = (radius + 1) as int32;
    uint32 x_min = clamp((x + 0.5) as int32 - iradius, 0, grid.res as int32) as uint32;
    uint32 x_max = clamp((x + 0.5) as int32 + iradius, 0, grid.res as int32) as uint32;
    uint32 y_min = clamp((y + 0.5) as int32 - iradius, 0, grid.res as int32) as uint32;
    uint32 y_max = clamp((y + 0.5) as int32 + iradius, 0, grid.res as int32) as uint32;

    uint32 ix = x_min-1; while ++ix < x_max {
        uint32 iy = y_min-1; while ++iy < y_max {
            float32 xf = ix as float32 - x;
            float32 yf = iy as float32 - y;
            float32 len = sqrtf(xf*xf + yf*yf);

            uint32 i = ix * grid.res + iy;
            grid.data[i] = clamp(radius - len, 0, 1);
        }
    }
}

int32 point_intersects(vec2 point, VoxelGrid grid) {
    uint32 x = point.x as uint32;
    uint32 y = point.y as uint32;

    let i1 = getIndex(grid.res, x, y + 1);
    let i2 = getIndex(grid.res, x + 1, y + 1);
    let i3 = getIndex(grid.res, x, y);
    let i4 = getIndex(grid.res, x + 1, y);

    let p1 = grid.data[i1];
    let p2 = grid.data[i2];
    let p3 = grid.data[i3];
    let p4 = grid.data[i4];

    uint8 mask = 0;
    if p1 > PointOnThreshold mask |= TopLeftBit;
    if p2 > PointOnThreshold mask |= TopRightBit;
    if p3 > PointOnThreshold mask |= BottomLeftBit;
    if p4 > PointOnThreshold mask |= BottomRightBit;

    switch mask {
        case 0x0F: return true;
    }

    return false;
}