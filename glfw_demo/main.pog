
/*

    compile command: ../bin/plang.exe build ../common/OpenGL.pog ../common/glfw3.pog cflags -lglfw3dll

    TODO:
        - 2d noise function
        - basic planet generation, using noise
        - player controller (gravity, collision, jump, jetpack)

    InProgress:
        - point to voxelgrid intersection func

    DONE:

*/

Transform camera;

void applyCamera() {
    glUniform1f(glGetUniformLocation(shader, "zoom"), camera.scale);
    glUniform2f(glGetUniformLocation(shader, "cam_pos"), camera.pos.x, camera.pos.y);
    glUniform1f(glGetUniformLocation(shader, "cam_rot"), camera.rot);
}

struct Transform {
    vec2 pos;
    float32 rot;
    float32 scale;
}

void applyTransform(Transform t) {
    glUniform2f(glGetUniformLocation(shader, "entity_pos"), t.pos.x, t.pos.y);
    glUniform1f(glGetUniformLocation(shader, "entity_rot"), t.rot);
    glUniform1f(glGetUniformLocation(shader, "entity_scale"), t.scale);
}

vec2 rotate_vec(vec2 dir, float32 angle) {
    float32 c = cosf(angle);
    float32 s = sinf(angle);

    vec2 res;
    res.x = c*dir.x + s*dir.y;
    res.y = -s*dir.x + c*dir.y;
    return res;
}

vec2 right(Transform t) { return vec(cosf(t.rot), sinf(t.rot)); }
vec2 up(Transform t) { return vec(-sinf(t.rot), cosf(t.rot)); }

vec2 local2world(Transform t, vec2 p) { return local2world(t, p.x, p.y); }
vec2 local2world(Transform t, float32 x, float32 y) {
    float32 c = cosf(t.rot) * t.scale;
    float32 s = sinf(t.rot) * t.scale;

    vec2 res;
    res.x = c*x + s*y + t.pos.x;
    res.y = -s*x + c*y + t.pos.y;
    return res;
}

vec2 world2local(Transform t, vec2 p) { return world2local(t, p.x, p.y); }
vec2 world2local(Transform t, float32 x, float32 y) {
    float32 c = cosf(t.rot) / t.scale;
    float32 s = sinf(t.rot) / t.scale;

    float32 px = x - t.pos.x;
    float32 py = y - t.pos.y;

    vec2 res;
    res.x = c*px - s*py;
    res.y = c*py + s*px;
    return res;
}

const entitiesCapacity = 256;
int32 entitiesLength = 0;
Entity* entities;
Entity* player;

struct Entity {
    Transform transform;
    Mesh mesh;
    vec2 vel;
}

const planetsCount = 16;
Planet* planets;

Entity* appendEntity(Mesh mesh) {
    if entitiesLength >= entitiesCapacity {
        print("Failed to append entity. Max limit reached.");
        return null;
    }

    let res = *entities[entitiesLength++];
    res.transform.pos = vec(0, 0);
    res.transform.scale = 1;
    res.transform.rot = 0;
    res.mesh = mesh;
    res.vel = vec(0, 0);
    return res;
}


Mesh genCircle(int32 res, float32 radius) {
    uint32 vertsCount = res as uint32 + 1;
    vec2 verts[vertsCount];
    verts[0].x = 0;
    verts[0].y = 0;

    for i in 1 .. res + 1 {
        float32 angle = i * Tau / res;
        verts[i].x = cosf(angle) * radius;
        verts[i].y = sinf(angle) * radius;
    }

    uint32 indsCount = (res as uint32) * 3;
    uint32 inds[indsCount];
    uint32 i = 0;
    uint32 v = 1;
    while i < indsCount {
        inds[i] = 0;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1;

    return createMesh(verts, vertsCount, inds, indsCount);
}

Planet genPlanet(float32 radius, float32 dist, float32 year) {
    Planet p;
    p.radius = radius;
    p.dist = dist;
    p.yearDuration = year;
    p.mesh = genCircle(round2int(36 * radius), radius);
    p.rot = 0.0;
    p.orbitOffset = Pi * random(dist as int32);

    return p;
}

void drawPlanet(Planet* planet) {
    glUniform2f(glGetUniformLocation(shader, "entity_pos"), planet.pos.x, planet.pos.y);
    glUniform1f(glGetUniformLocation(shader, "entity_rot"), planet.rot);
    drawMesh(planet.mesh);
}

struct Planet {
    Mesh mesh;
    vec2 pos;
    float32 rot;
    float32 radius;
    float32 dist;
    float32 yearDuration;
    float32 orbitOffset;
}

void updateEntity(Entity* entity) {
    entity.transform.pos = add(entity.transform.pos, entity.vel);

    for i in 0 .. planetsCount {
        Planet* planet = *planets[i];

        vec2 diff = sub(entity.transform.pos, planet.pos);
        vec2 normal = normalize(diff);

        float32 intersection = length(diff) - planet.radius; // NOTE: we can neglect the entitys radius because its always 1.0

        float32 planetArea = Pi * planet.radius * planet.radius;
        float32 planetMass = planetArea; // assuming the same uniform mass-density on all planets.
        vec2 gravity = mul(normal, planetMass / sqlength(diff) * -0.000003);
        // entity.vel = add(entity.vel, gravity);

        if (intersection <= 0.0) {

            vec2 correction = mul(normal, -intersection);
            entity.transform.pos = add(entity.transform.pos, correction);

            // entity.vel = reflect(entity.vel, normal); // bounce
            entity.vel = add(entity.vel, mul(normal, -dot(entity.vel, normal))); // cancel velocity in direction of surface
        }
    }

    Intersection intersection;
    if point_intersects(entity.transform.pos, *voxelGrid, *intersection) {
        vec2 normal = intersection.surface_normal;
        vec2 correction = mul(normal, -intersection.distance);
        entity.transform.pos = add(entity.transform.pos, correction);

        entity.vel = add(entity.vel, mul(normal, -dot(entity.vel, normal))); // cancel velocity in direction of surface
    }
}

void load() {

    camera.rot = 0;
    camera.scale = 40;

    glfwSetScrollCallback(window, mouse_scrollCallback);

    entities = malloc(sizeof(Entity) * entitiesCapacity);
    planets = malloc(sizeof(Planet) * planetsCount);

    for i in 0 .. planetsCount {
        float32 r = 20.0 + random(i as int32);
        Planet p = genPlanet(r,
                            70.0 + r * 30.0 * i,
                            100.0 + 20.0 * random(2 * i + 100));
        planets[i] = p;
    }


    player = appendEntity(genCircle(4, 0.1f));

    voxelGrid = generatePlanet();
    voxelGrid.transform.pos = vec(-20, 30);
    // voxelGrid.transform.rot = Pi / 3;
    print("Voxelgrid Tri Count: ", length(voxelGrid.inds) / 3, "\n");

    voxelMesh_circle = genCircle(360, 40);
}

VoxelGrid generatePlanet() {
    VoxelGrid grid = createVoxelGrid(100);
    grid.transform.scale = 1;

    float32 half = grid.res as float32 / 2;

    for uint32 x in 0 .. grid.res {
        for uint32 y in 0 .. grid.res {
            float32 xf = x as float32 - half;
            float32 yf = y as float32 - half;
            float32 len = sqrtf(xf*xf + yf*yf);

            uint32 i = x * grid.res + y;

            grid.data[i] = clamp(40 - len, 0, 1);
            // if len < 40 grid.data[i] = clamp(random(i as int32), 0, 1);
            // else grid.data[i] = 0;
        }
    }

    updateGridMesh(*grid);
    return grid;
}

VoxelGrid voxelGrid;
Mesh voxelMesh_circle;

int32 main() {
    if !glfwInit() return -1;

    let width = 1600;
    let height = 900;
    window = glfwCreateWindow(width, height, "Window", null, null);
    if !window {
        glfwTerminate();
        return -1;
    }


    glfwMakeContextCurrent(window);

    loadGL();

    glClearColor(0.05, 0.05, 0.05, 1.0);

    load();

    let error = glGetError();
    if error print("OpenGL error. ", error, "\n");

    while !glfwWindowShouldClose(window) {

        vec2 wasd;
        wasd.x = 0f;
        wasd.y = 0f;
        if key('W') wasd.y += 1f;
        if key('S') wasd.y -= 1f;
        if key('A') wasd.x -= 1f;
        if key('D') wasd.x += 1f;
        // if (wasd.x != 0.0f or wasd.y != 0.0f) {
        //     vec2Normalize(&wasd);
        // }

        if key('F') { player.vel.x = 0.0; player.vel.y = 0.0; }

        float32 c = cosf(player.transform.rot);
        float32 s = sinf(player.transform.rot);
        vec2 dir = vec(dot(vec(c, s), wasd), dot(vec(-s, c), wasd));

        player.vel = add(player.vel, mul(dir, 0.01));


        int32 w;
        int32 h;
        glfwGetFramebufferSize(window, *w, *h);
        glViewport(0, 0, w, h);

        glClear(GL_COLOR_BUFFER_BIT);

        float32 time = glfwGetTime() as float32;
        time = 0.0;
        for i in 0 .. planetsCount {
            Planet* planet = *planets[i];
            float32 t = Pi * 2.0;
            planet.pos.x = cosf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            planet.pos.y = sinf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            drawPlanet(planet);
        }


        for i in 0 .. entitiesLength {
            let e = *entities[i];
            updateEntity(e);
        }

        if key('Q') camera.rot -= 0.05;
        if key('E') camera.rot += 0.05;

        camera.pos = player.transform.pos;
        player.transform.rot = camera.rot;
        applyCamera();

        for i in 0 .. entitiesLength {
            let e = *entities[i];
            applyTransform(e.transform);
            drawMesh(e.mesh);
        }


        { // voxels

            // voxelGrid.transform.rot += 0.0002;

            let mouseCoord = getMouseWorldCoord();

            Intersection intersection;
            if point_intersects(mouseCoord, *voxelGrid, *intersection) {
                // let center = calcCenterOfMass(*voxelGrid);
                // glUniform2f(glGetUniformLocation(shader, "entity_pos"), center.x, center.y);
                // drawMesh(voxelMesh_circle);
                print("Intersects ", intersection.distance, "\n");
            }

            if mouse(Left_Mouse) {
                // VoxelGrid_addCircle(*voxelGrid, 3, mouseCoord.x, mouseCoord.y);
                let local = getLocalCoords(*voxelGrid, mouseCoord.x, mouseCoord.y);
                voxelGrid.data[voxelGrid.res * round2int(local.x) + round2int(local.y)] += 0.01;
                updateGridMesh(*voxelGrid);
            } else if mouse(Right_Mouse) {
                VoxelGrid_removeCircle(*voxelGrid, 3, mouseCoord.x, mouseCoord.y);
                updateGridMesh(*voxelGrid);
            }

            // glUniform2f(glGetUniformLocation(shader, "entity_pos"), 0, 0);
            applyTransform(voxelGrid.transform);
            drawMesh(voxelGrid.mesh);
            // Draw vertices as points
            glBindVertexArray(voxelGrid.mesh.vao);
            glDrawArrays(GL_POINTS, 0, voxelGrid.numVerts as int32);
            glBindVertexArray(0);
        }

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();
}
