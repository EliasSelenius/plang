
struct Camera {
    vec2 pos;
    float32 rot;
    float32 zoom;
}
Camera camera;

void applyCamera() {
    glUniform1f(glGetUniformLocation(shader, "zoom"), camera.zoom);
    glUniform2f(glGetUniformLocation(shader, "cam_pos"), camera.pos.x, camera.pos.y);
    glUniform1f(glGetUniformLocation(shader, "cam_rot"), camera.rot);
}

struct Transform {
    vec2 pos;
    float32 rot;
    float32 scale;
}

vec2 up(Transform t) {
    return vec(-sinf(t.rot), cosf(t.rot));
}

const entitiesCapacity = 256;
int32 entitiesLength = 0;
Entity* entities;
Entity* player;

const planetsCount = 16;
Planet* planets;

Entity* appendEntity(Entity e) {
    if entitiesLength >= entitiesCapacity {
        println("Failed to append entity. Max limit reached.");
        return null;
    }

    let res = *entities[entitiesLength++];
    @res = e;
    return res;
}


Mesh genCircle(int32 res, float32 radius) {
    uint32 vertsCount = res as uint32 + 1u;
    vec2 verts[vertsCount];
    verts[0].x = 0f;
    verts[0].y = 0f;

    int32 i = 1;
    while i < res + 1 {
        float32 angle = (i as float32) * Tau / res;
        verts[i].x = cosf(angle) * radius;
        verts[i].y = sinf(angle) * radius;
        ++i;
    }

    uint32 indsCount = (res as uint32) * 3u;
    uint32 inds[indsCount];
    i = 0;
    uint32 v = 1u;
    while i < indsCount {
        inds[i] = 0u;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1u;

    return createMesh(verts, vertsCount, inds, indsCount);
}

Planet genPlanet(float32 radius, float32 dist, float32 year) {
    Planet p;
    p.radius = radius;
    p.dist = dist;
    p.yearDuration = year;
    p.mesh = genCircle(36 * radius, radius);
    p.rot = 0.0;
    p.orbitOffset = Pi * random(dist as int32);

    return p;
}

void drawPlanet(Planet* planet) {
    glUniform2f(glGetUniformLocation(shader, "entity_pos"), planet.pos.x, planet.pos.y);
    glUniform1f(glGetUniformLocation(shader, "entity_rot"), planet.rot);
    drawMesh(planet.mesh);
}

struct Entity {
    Mesh mesh;
    vec2 pos;
    float32 rot;
    vec2 vel;
}

struct Planet {
    Mesh mesh;
    vec2 pos;
    float32 rot;
    float32 radius;
    float32 dist;
    float32 yearDuration;
    float32 orbitOffset;
}

void updateEntity(Entity* entity) {
    entity.pos = add(entity.pos, entity.vel);

    uint32 i = 0u;
    while i < planetsCount {
        Planet* planet = *planets[i++];

        vec2 diff = sub(entity.pos, planet.pos);
        vec2 normal = normalize(diff);

        float32 intersection = length(diff) - planet.radius; // NOTE: we can neglect the entitys radius because its always 1.0

        float32 planetArea = Pi * planet.radius * planet.radius;
        float32 planetMass = planetArea; // assuming the same uniform mass-density on all planets.
        vec2 gravity = mul(normal, planetMass / sqlength(diff) * -0.000003);
        // entity.vel = add(entity.vel, gravity);

        if (intersection <= 0.0) {

            vec2 correction = mul(normal, -intersection);
            entity.pos = add(entity.pos, correction);

            // entity.vel = reflect(entity.vel, normal); // bounce
            entity.vel = add(entity.vel, mul(normal, -dot(entity.vel, normal))); // cancel velocity in direction of surface
        }
    }
}

void load() {

    camera.rot = 0;
    camera.zoom = 40;

    glfwSetScrollCallback(window, mouse_scrollCallback);

    entities = malloc(sizeof(Entity) * entitiesCapacity);
    planets = malloc(sizeof(Planet) * planetsCount);

    uint32 i = 0u;
    while i < planetsCount {
        float32 r = 20.0 + random(i as int32);
        Planet p = genPlanet(r,
                            70.0 + r * 30.0 * i,
                            100.0 + 20.0 * random(2 * i + 100));
        planets[i++] = p;
    }


    Entity entity;
    entity.mesh = genCircle(4, 0.1f);
    entity.pos.x = 0;
    entity.pos.y = 0;
    player = appendEntity(entity);

    voxelGrid = generatePlanet();
    voxelMesh = generateMesh(voxelGrid);
    printf("%s %d\n", "VoxelMesh Tri Count:", length(voxelMesh.inds) / 3);

    voxelMesh_circle = genCircle(360, 40);
}

VoxelGrid generatePlanet() {
    VoxelGrid grid;
    grid.res = 100;
    grid.data = alloc float32[grid.res * grid.res];

    float32 half = grid.res as float32 / 2;

    uint32 x = -1; while ++x < grid.res {
        uint32 y = -1; while ++y < grid.res {
            float32 xf = x as float32 - half;
            float32 yf = y as float32 - half;
            float32 len = sqrtf(xf*xf + yf*yf);

            uint32 i = x * grid.res + y;

            grid.data[i] = clamp(40 - len, 0, 1);
            // if len < 40 grid.data[i] = clamp(random(i as int32), 0, 1);
            // else grid.data[i] = 0;
        }
    }

    return grid;
}

VoxelGrid voxelGrid;
VoxelMesh voxelMesh;
Mesh voxelMesh_circle;

int32 main() {
    if !glfwInit() return -1;

    let width = 1600;
    let height = 900;
    window = glfwCreateWindow(width, height, "Window", null, null);
    if !window {
        glfwTerminate();
        return -1;
    }


    glfwMakeContextCurrent(window);

    loadGL();

    glClearColor(0.05, 0.05, 0.05, 1.0);

    load();

    let error = glGetError();
    if error printf("%s %d\n", "OpenGL error.", error);

    while !glfwWindowShouldClose(window) {

        vec2 wasd;
        wasd.x = 0f;
        wasd.y = 0f;
        if key('W') wasd.y += 1f;
        if key('S') wasd.y -= 1f;
        if key('A') wasd.x -= 1f;
        if key('D') wasd.x += 1f;
        // if (wasd.x != 0.0f or wasd.y != 0.0f) {
        //     vec2Normalize(&wasd);
        // }

        if key('F') { player.vel.x = 0.0; player.vel.y = 0.0; }

        player.vel = add(player.vel, mul(wasd, 0.01));


        int32 w;
        int32 h;
        glfwGetFramebufferSize(window, *w, *h);
        glViewport(0, 0, w, h);

        glClear(GL_COLOR_BUFFER_BIT);

        float32 time = glfwGetTime() as float32;
        time = 0.0;
        int32 i = 0;
        while i < planetsCount {
            Planet* planet = *planets[i++];
            float32 t = Pi * 2.0;
            planet.pos.x = cosf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            planet.pos.y = sinf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            drawPlanet(planet);
        }


        i = 0;
        while i < entitiesLength {
            let e = *entities[i++];
            updateEntity(e);
        }

        if key('Q') camera.rot += 0.05;
        if key('E') camera.rot -= 0.05;

        camera.pos = player.pos;
        applyCamera();

        i = 0;
        while i < entitiesLength {
            let e = *entities[i++];
            glUniform2f(glGetUniformLocation(shader, "entity_pos"), e.pos.x, e.pos.y);
            glUniform1f(glGetUniformLocation(shader, "entity_rot"), e.rot);
            drawMesh(e.mesh);
        }


        { // voxels

            let mouseCoord = getMouseWorldCoord();

            if mouse(Left_Mouse) {
                uint32 x = (mouseCoord.x + 0.5) as uint32;
                uint32 y = (mouseCoord.y + 0.5) as uint32;
                if x < voxelGrid.res and y < voxelGrid.res {
                    // voxelGrid.data[x * voxelGrid.res + y] = 0.5;
                    VoxelGrid_addCircle(voxelGrid, 3, mouseCoord.x, mouseCoord.y);
                    updateGridMesh(voxelGrid, *voxelMesh);
                }
            } else if mouse(Right_Mouse) {
                uint32 x = (player.pos.x + 0.5) as uint32;
                uint32 y = (player.pos.y + 0.5) as uint32;
                if x < voxelGrid.res and y < voxelGrid.res {
                    voxelGrid.data[x * voxelGrid.res + y] = 0;
                    updateGridMesh(voxelGrid, *voxelMesh);
                }
            }

            if key('T') {
                VoxelGrid_addCircle(voxelGrid, 3, player.pos.x, player.pos.y);
                updateGridMesh(voxelGrid, *voxelMesh);
            }

            glUniform2f(glGetUniformLocation(shader, "entity_pos"), 0, 0);
            drawMesh(voxelMesh.mesh);
            glBindVertexArray(voxelMesh.mesh.vao);
            glDrawArrays(GL_POINTS, 0, voxelMesh.numVerts as int32);
            glBindVertexArray(0);
            glUniform2f(glGetUniformLocation(shader, "entity_pos"), 50, 50);
            // drawMesh(voxelMesh_circle);
            // if point_intersects(player.pos, voxelGrid) { }
        }

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();
}
