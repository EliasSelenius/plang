
vec2 cam_pos;
float32 cam_zoom = 40f;

const entitiesCapacity = 256;
int32 entitiesLength = 0;
Entity* entities;
Entity* player;

const planetsCount = 16;
Planet* planets;

Entity* appendEntity(Entity e) {
    if entitiesLength >= entitiesCapacity {
        println("Failed to append entity. Max limit reached.");
        return null;
    }

    let res = *entities[entitiesLength++];
    @res = e;
    return res;
}


void GLFWscrollfunCallback(GLFWwindow* window, float64 x, float64 y) {
    cam_zoom -= cam_zoom * (y as float32) * 0.1;
    cam_zoom = clamp(cam_zoom, 1.0, 10000.0);
}

Mesh genCircle(int32 res, float32 radius) {
    uint32 vertsCount = res as uint32 + 1u;
    vec2 verts[vertsCount];
    verts[0].x = 0f;
    verts[0].y = 0f;

    int32 i = 1;
    while i < res + 1 {
        float32 angle = (i as float32) * Tau / res;
        verts[i].x = cosf(angle) * radius;
        verts[i].y = sinf(angle) * radius;
        ++i;
    }

    uint32 indsCount = (res as uint32) * 3u;
    uint32 inds[indsCount];
    i = 0;
    uint32 v = 1u;
    while i < indsCount {
        inds[i] = 0u;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1u;

    return createMesh(verts, vertsCount, inds, indsCount);
}

Planet genPlanet(float32 radius, float32 dist, float32 year) {
    Planet p;
    p.radius = radius;
    p.dist = dist;
    p.yearDuration = year;
    p.mesh = genCircle(36 * radius, radius);
    p.rot = 0.0;
    p.orbitOffset = Pi * random(dist as int32);

    return p;
}

void drawPlanet(Planet* planet) {
    glUniform2f(glGetUniformLocation(shader, "entity_pos"), planet.pos.x, planet.pos.y);
    drawMesh(planet.mesh);
}

struct Entity {
    Mesh mesh;
    vec2 pos;
    float32 rot;
    vec2 vel;
}

struct Planet {
    Mesh mesh;
    vec2 pos;
    float32 rot;
    float32 radius;
    float32 dist;
    float32 yearDuration;
    float32 orbitOffset;
}

int32 key(char c) {
    return glfwGetKey(window, c as int32);
}

void updateEntity(Entity* entity) {
    entity.pos = add(entity.pos, entity.vel);

    uint32 i = 0u;
    while i < planetsCount {
        Planet* planet = *planets[i++];

        vec2 diff = sub(entity.pos, planet.pos);
        vec2 normal = normalize(diff);

        float32 intersection = length(diff) - planet.radius; // NOTE: we can neglect the entitys radius because its always 1.0

        float32 planetArea = Pi * planet.radius * planet.radius;
        float32 planetMass = planetArea; // assuming the same uniform mass-density on all planets.
        vec2 gravity = mul(normal, planetMass / sqlength(diff) * -0.000003);
        // entity.vel = add(entity.vel, gravity);

        if (intersection <= 0.0) {

            vec2 correction = mul(normal, -intersection);
            entity.pos = add(entity.pos, correction);

            // entity.vel = reflect(entity.vel, normal); // bounce
            entity.vel = add(entity.vel, mul(normal, -dot(entity.vel, normal))); // cancel velocity in direction of surface
        }
    }

    cam_pos = player.pos;
    glUniform2f(glGetUniformLocation(shader, "cam_pos"), cam_pos.x, cam_pos.y);
}

void load() {
    entities = malloc(sizeof(Entity) * entitiesCapacity);
    planets = malloc(sizeof(Planet) * planetsCount);

    uint32 i = 0u;
    while i < planetsCount {
        float32 r = 20.0 + random(i as int32);
        Planet p = genPlanet(r,
                            70.0 + r * 30.0 * i,
                            100.0 + 20.0 * random(2 * i + 100));
        planets[i++] = p;
    }


    Entity entity;
    entity.mesh = genCircle(4, 0.1f);

    player = appendEntity(entity);

}

int32 main() {

    if !glfwInit() {
        return -1;
    }

    let width = 1600;
    let height = 900;
    window = glfwCreateWindow(width, height, "Window", null, null);
    if !window {
        glfwTerminate();
        return -1;
    }


    glfwMakeContextCurrent(window);

    loadGL();

    glClearColor(0.05, 0.05, 0.05, 1.0);

    load();

    let error = glGetError();
    if error {
        printf("%s %d\n", "OpenGL error.", error);
    }

    while !glfwWindowShouldClose(window) {

        vec2 wasd;
        wasd.x = 0f;
        wasd.y = 0f;
        if key('W') { wasd.y += 1f; }
        if key('S') { wasd.y -= 1f; }
        if key('A') { wasd.x -= 1f; }
        if key('D') { wasd.x += 1f; }
        // if (wasd.x != 0.0f or wasd.y != 0.0f) {
        //     vec2Normalize(&wasd);
        // }

        if key('F') { player.vel.x = 0.0; player.vel.y = 0.0; }

        player.vel = add(player.vel, mul(wasd, 0.01));

        // cam_pos.x += wasd.x * 0.05 * cam_zoom;
        // cam_pos.y += wasd.y * 0.05 * cam_zoom;

        glUniform1f(glGetUniformLocation(shader, "zoom"), cam_zoom);

        int32 w;
        int32 h;
        glfwGetFramebufferSize(window, *w, *h);
        glViewport(0, 0, w, h);

        glClear(GL_COLOR_BUFFER_BIT);

        float32 time = glfwGetTime() as float32;
        time = 0.0;
        int32 i = 0;
        while i < planetsCount {
            Planet* planet = *planets[i++];
            float32 t = Pi * 2.0;
            planet.pos.x = cosf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            planet.pos.y = sinf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            drawPlanet(planet);
        }


        i = 0;
        while i < entitiesLength {
            let e = *entities[i];
            updateEntity(e);
            glUniform2f(glGetUniformLocation(shader, "entity_pos"), e.pos.x, e.pos.y);
            drawMesh(e.mesh);
            i++;
        }


        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();
}
