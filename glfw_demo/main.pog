
vec2 cam_pos;
float cam_zoom = 40f;

const entitiesCapacity = 256;
int entitiesLength = 0;
Entity* entities;
Entity* player;

const planetsCount = 16;
Planet* planets;

Entity* appendEntity(Entity e) {
    if entitiesLength >= entitiesCapacity {
        println("Failed to append entity. Max limit reached.");
        return null;
    }

    let res = *entities[entitiesLength++];
    @res = e;
    return res;
}


void GLFWscrollfunCallback(GLFWwindow* window, double x, double y) {
    cam_zoom -= cam_zoom * (y as float) * 0.1;
    cam_zoom = clamp(cam_zoom, 1.0, 100.0);
}

Mesh genCircle(int res, float radius) {
    uint vertsCount = res as uint + 1u;
    vec2 verts[vertsCount];
    verts[0].x = 0f;
    verts[0].y = 0f;

    int i = 1;
    while i < res + 1 {
        float angle = (i as float) * Tau / res;
        verts[i].x = cosf(angle) * radius;
        verts[i].y = sinf(angle) * radius;
        ++i;
    }

    uint indsCount = (res as uint) * 3u;
    uint inds[indsCount];
    i = 0;
    uint v = 1u;
    while i < indsCount {
        inds[i] = 0u;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1u;

    return createMesh(verts, vertsCount, inds, indsCount);
}

Planet genPlanet(float radius, float dist, float year) {
    Planet p;
    p.radius = radius;
    p.dist = dist;
    p.yearDuration = year;
    p.mesh = genCircle(36 * radius, radius);
    p.rot = 0.0;
    p.orbitOffset = Pi * random(dist);

    return p;
}

void drawPlanet(Planet* planet) {
    glUniform2f(glGetUniformLocation(shader, "entity_pos"), planet.pos.x, planet.pos.y);
    drawMesh(planet.mesh);
}

struct Entity {
    Mesh mesh;
    vec2 pos;
    float rot;
    vec2 vel;
}

struct Planet {
    Mesh mesh;
    vec2 pos;
    float rot;
    float radius;
    float dist;
    float yearDuration;
    float orbitOffset;
}

int key(char c) {
    return glfwGetKey(window, c as int);
}

void updateEntity(Entity* entity) {
    entity.pos = add(entity.pos, entity.vel);

    uint i = 0u;
    while i < planetsCount {
        Planet* planet = *planets[i++];

        vec2 diff = sub(entity.pos, planet.pos);
        vec2 normal = normalize(diff);

        float intersection = length(diff) - planet.radius; // NOTE: we can neglect the entitys radius because its always 1.0

        float planetArea = Pi * planet.radius * planet.radius;
        float planetMass = planetArea; // assuming the same uniform mass-density on all planets.
        vec2 gravity = mul(normal, planetMass / sqlength(diff) * -0.003);
        entity.vel = add(entity.vel, gravity);

        if (intersection <= 0.0) {

            vec2 correction = mul(normal, intersection * -1.0);
            entity.pos = add(entity.pos, correction);

            // entity.vel = reflect(entity.vel, normal); // bounce
            entity.vel = add(entity.vel, mul(normal, dot(entity.vel, normal) * -1.0)); // cancel velocity in direction of surface
        }
    }

    cam_pos = player.pos;
    glUniform2f(glGetUniformLocation(shader, "cam_pos"), cam_pos.x, cam_pos.y);
}

void load() {
    entities = malloc(sizeof(Entity) * entitiesCapacity);
    planets = malloc(sizeof(Planet) * planetsCount);

    uint i = 0u;
    while i < planetsCount {
        Planet p = genPlanet(2.0 + random(i as float), 14.0 + 6.0 * i, 100.0 + 20.0 * random(2.0 * i as float + 100.0));
        planets[i++] = p;
    }


    Entity entity;
    entity.mesh = genCircle(4, 0.1f);

    player = appendEntity(entity);

}

let main() {

    if !glfwInit() {
        return -1;
    }

    let width = 1600;
    let height = 900;
    window = glfwCreateWindow(width, height, "Window", null, null);
    if !window {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    loadGL();

    glClearColor(0.05, 0.05, 0.05, 1.0);

    load();

    let error = glGetError();
    if error {
        printf("%s %d\n", "OpenGL error.", error);
    }

    while !glfwWindowShouldClose(window) {

        vec2 wasd;
        wasd.x = 0f;
        wasd.y = 0f;
        if key('W') { wasd.y += 1f; }
        if key('S') { wasd.y -= 1f; }
        if key('A') { wasd.x -= 1f; }
        if key('D') { wasd.x += 1f; }
        // if (wasd.x != 0.0f or wasd.y != 0.0f) {
        //     vec2Normalize(&wasd);
        // }

        if key('F') { player.vel.x = 0.0; player.vel.y = 0.0; }

        player.vel = add(player.vel, mul(wasd, 0.01));

        // cam_pos.x += wasd.x * 0.05 * cam_zoom;
        // cam_pos.y += wasd.y * 0.05 * cam_zoom;

        glUniform1f(glGetUniformLocation(shader, "zoom"), cam_zoom);

        int w;
        int h;
        glfwGetFramebufferSize(window, *w, *h);
        glViewport(0, 0, w, h);

        glClear(GL_COLOR_BUFFER_BIT);

        float time = glfwGetTime() as float;
        // time = 0.0;
        int i = 0;
        while i < planetsCount {
            Planet* planet = *planets[i++];
            float t = Pi * 2.0;
            planet.pos.x = cosf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            planet.pos.y = sinf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
            drawPlanet(planet);
        }


        i = 0;
        while i < entitiesLength {
            let e = *entities[i];
            updateEntity(e);
            glUniform2f(glGetUniformLocation(shader, "entity_pos"), e.pos.x, e.pos.y);
            drawMesh(e.mesh);
            i++;
        }


        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();
}
